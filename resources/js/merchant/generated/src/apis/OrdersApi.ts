/* tslint:disable */
/* eslint-disable */
/**
 * User Wallet API
 * API for User Wallet application with order and transaction management
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateMerchantOrderRequest,
  CreateMerchantWithdrawalRequest,
  GetMerchantOrderRules200Response,
  GetMerchantOrders200Response,
  Order,
  UpdateMerchantOrderRequest,
} from '../models/index';
import {
    CreateMerchantOrderRequestFromJSON,
    CreateMerchantOrderRequestToJSON,
    CreateMerchantWithdrawalRequestFromJSON,
    CreateMerchantWithdrawalRequestToJSON,
    GetMerchantOrderRules200ResponseFromJSON,
    GetMerchantOrderRules200ResponseToJSON,
    GetMerchantOrders200ResponseFromJSON,
    GetMerchantOrders200ResponseToJSON,
    OrderFromJSON,
    OrderToJSON,
    UpdateMerchantOrderRequestFromJSON,
    UpdateMerchantOrderRequestToJSON,
} from '../models/index';

export interface CancelMerchantOrderRequest {
    order: number;
}

export interface ConfirmMerchantOrderRequest {
    order: number;
}

export interface CreateMerchantOrderOperationRequest {
    createMerchantOrderRequest: CreateMerchantOrderRequest;
}

export interface CreateMerchantWithdrawalOperationRequest {
    createMerchantWithdrawalRequest: CreateMerchantWithdrawalRequest;
}

export interface GetMerchantOrderRequest {
    order: number;
}

export interface GetMerchantOrdersRequest {
    dateFrom?: Date;
    dateTo?: Date;
    minAmount?: number;
    maxAmount?: number;
    status?: GetMerchantOrdersStatusEnum;
    receiverUserId?: number;
}

export interface RejectMerchantOrderRequest {
    order: number;
}

export interface UpdateMerchantOrderOperationRequest {
    order: number;
    updateMerchantOrderRequest: UpdateMerchantOrderRequest;
}

/**
 * 
 */
export class OrdersApi extends runtime.BaseAPI {

    /**
     * Cancel an order
     */
    async cancelMerchantOrderRaw(requestParameters: CancelMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling cancelMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/{order}`;
        urlPath = urlPath.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters['order'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Cancel an order
     */
    async cancelMerchantOrder(requestParameters: CancelMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.cancelMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Confirm a pending order
     */
    async confirmMerchantOrderRaw(requestParameters: ConfirmMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling confirmMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/{order}/confirm`;
        urlPath = urlPath.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters['order'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Confirm a pending order
     */
    async confirmMerchantOrder(requestParameters: ConfirmMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.confirmMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new order
     */
    async createMerchantOrderRaw(requestParameters: CreateMerchantOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['createMerchantOrderRequest'] == null) {
            throw new runtime.RequiredError(
                'createMerchantOrderRequest',
                'Required parameter "createMerchantOrderRequest" was null or undefined when calling createMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMerchantOrderRequestToJSON(requestParameters['createMerchantOrderRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Create a new order
     */
    async createMerchantOrder(requestParameters: CreateMerchantOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.createMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a withdrawal request
     */
    async createMerchantWithdrawalRaw(requestParameters: CreateMerchantWithdrawalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['createMerchantWithdrawalRequest'] == null) {
            throw new runtime.RequiredError(
                'createMerchantWithdrawalRequest',
                'Required parameter "createMerchantWithdrawalRequest" was null or undefined when calling createMerchantWithdrawal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/withdrawal`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMerchantWithdrawalRequestToJSON(requestParameters['createMerchantWithdrawalRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Create a withdrawal request
     */
    async createMerchantWithdrawal(requestParameters: CreateMerchantWithdrawalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.createMerchantWithdrawalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific order
     */
    async getMerchantOrderRaw(requestParameters: GetMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling getMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/{order}`;
        urlPath = urlPath.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters['order'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Get a specific order
     */
    async getMerchantOrder(requestParameters: GetMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.getMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get order validation rules and limits
     */
    async getMerchantOrderRulesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetMerchantOrderRules200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/rules`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetMerchantOrderRules200ResponseFromJSON(jsonValue));
    }

    /**
     * Get order validation rules and limits
     */
    async getMerchantOrderRules(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetMerchantOrderRules200Response> {
        const response = await this.getMerchantOrderRulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List user\'s orders with optional filtering
     */
    async getMerchantOrdersRaw(requestParameters: GetMerchantOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetMerchantOrders200Response>> {
        const queryParameters: any = {};

        if (requestParameters['dateFrom'] != null) {
            queryParameters['date_from'] = (requestParameters['dateFrom'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['dateTo'] != null) {
            queryParameters['date_to'] = (requestParameters['dateTo'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['minAmount'] != null) {
            queryParameters['min_amount'] = requestParameters['minAmount'];
        }

        if (requestParameters['maxAmount'] != null) {
            queryParameters['max_amount'] = requestParameters['maxAmount'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['receiverUserId'] != null) {
            queryParameters['receiver_user_id'] = requestParameters['receiverUserId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetMerchantOrders200ResponseFromJSON(jsonValue));
    }

    /**
     * List user\'s orders with optional filtering
     */
    async getMerchantOrders(requestParameters: GetMerchantOrdersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetMerchantOrders200Response> {
        const response = await this.getMerchantOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get pending transfers received by the user
     */
    async getMerchantPendingTransfersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Order>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/pending-transfers`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrderFromJSON));
    }

    /**
     * Get pending transfers received by the user
     */
    async getMerchantPendingTransfers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Order>> {
        const response = await this.getMerchantPendingTransfersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Reject a pending order
     */
    async rejectMerchantOrderRaw(requestParameters: RejectMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling rejectMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/{order}/reject`;
        urlPath = urlPath.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters['order'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Reject a pending order
     */
    async rejectMerchantOrder(requestParameters: RejectMerchantOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.rejectMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing order
     */
    async updateMerchantOrderRaw(requestParameters: UpdateMerchantOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Order>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling updateMerchantOrder().'
            );
        }

        if (requestParameters['updateMerchantOrderRequest'] == null) {
            throw new runtime.RequiredError(
                'updateMerchantOrderRequest',
                'Required parameter "updateMerchantOrderRequest" was null or undefined when calling updateMerchantOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("sanctum", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/merchant/orders/{order}`;
        urlPath = urlPath.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters['order'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMerchantOrderRequestToJSON(requestParameters['updateMerchantOrderRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderFromJSON(jsonValue));
    }

    /**
     * Update an existing order
     */
    async updateMerchantOrder(requestParameters: UpdateMerchantOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Order> {
        const response = await this.updateMerchantOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetMerchantOrdersStatusEnum = {
    PendingPayment: 'pending_payment',
    PendingApproval: 'pending_approval',
    Completed: 'completed',
    Cancelled: 'cancelled',
    Refunded: 'refunded'
} as const;
export type GetMerchantOrdersStatusEnum = typeof GetMerchantOrdersStatusEnum[keyof typeof GetMerchantOrdersStatusEnum];
